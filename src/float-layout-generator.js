var FloatLayoutGenerator = (function(){
  // argument 'style' is the style of parent.
  // if <body><float1>..</float1><float2>...</float2></body>,
  // style of this contructor is 'body.style'
  function FloatLayoutGenerator(style, stream){
    LayoutGenerator.call(this, style, stream);
    this.generators = this._getFloatedGenerators();

    // create child generator to yield rest-space of float-elements with logical-float "start".
    // notice that this generator uses 'clone' style, because size of space changes by position,
    // but on the other hand, original style is referenced by float-elements as parent style.
    // so we must keep original style immutable.
    this.setChildLayout(new BlockLayoutGenerator(style.clone({"float":"start"}), stream));
  }
  Class.extend(FloatLayoutGenerator, LayoutGenerator);

  FloatLayoutGenerator.prototype.hasNext = function(){
    if(this.hasNextFloat()){
      return true;
    }
    return LayoutGenerator.prototype.hasNext.call(this);
  };

  FloatLayoutGenerator.prototype.hasNextFloat = function(){
    return List.exists(this.generators, function(gen){
      return gen.hasNext();
    });
  };

  FloatLayoutGenerator.prototype.yield = function(context){
    context = context || this._createStartContext();
    var stack = this._yieldFloatStack(context);
    var rest_measure = context.getInlineRestMeasure();
    var rest_extent = context.getBlockRestExtent();
    return this._yieldFloat(context, stack, rest_measure, rest_extent);
  };

  FloatLayoutGenerator.prototype._yieldFloat = function(context, stack, rest_measure, rest_extent){
    //console.log("yieldFloat(%d,%d)", rest_measure, rest_extent);
    if(rest_measure <= 0){
      return null;
    }
    var flow = this.style.flow;

    // no more floated layout, just yield rest area.
    if(stack.isEmpty()){
      return this._yieldFloatSpace(context, rest_measure, rest_extent);
    }
    /*
      <------ rest_measure ---->
      --------------------------
      |       |                |
      | group | rest           | => group_set(wrap_float)
      |       |                |
      --------------------------
    */
    var group = stack.pop(); // pop float group(notice that this stack is ordered by extent asc, so largest one is first obtained).
    var rest = this._yieldFloat(context, stack, rest_measure - group.getMeasure(flow), group.getExtent(flow)); // yield rest area of this group in inline-flow(recursive).
    var group_set = this._wrapFloat(context, group, rest); // wrap these 2 floated layout as one block.

    /*
      To understand rest_extent_space, remember that this func is called recursivelly,
      and argument 'rest_extent' is generated by 'previous' largest float group(g2).
      
      <--- rest_measure --->
      ----------------------------
      |    |                |    |
      | g1 | rest           | g2 |
      |    |                |    |
      ----------------------|    |
      |  rest_extent_space  |    |
      ----------------------------
    */
    var rest_extent_space = rest_extent - group.getExtent(flow);

    // no more space left in block-flow direction, or no more stream.
    if(rest_extent_space <= 0 || !this.stream.hasNext()){
      return group_set;
    }

    /*
      <------ rest_measure ---->
      --------------------------
      |       |                |
      | group | rest           | => group_set(wrap_float)
      |       |                |
      --------------------------
      |  rest_extent_space     | => rest_extent - group_set.extent
      --------------------------
     */
    // if there is space in block-flow direction, yield rest space and wrap tfloated-set and rest-space as one.
    var space = this._yieldFloatSpace(context, rest_measure, rest_extent_space);
    return this._wrapBlock(context, group_set, space);
  };
  
  FloatLayoutGenerator.prototype._sortFloatRest = function(floated, rest){
    var floated_elements = floated.getElements();
    return floated.isFloatStart()? floated_elements.concat(rest) : [rest].concat(floated_elements);
  };

  FloatLayoutGenerator.prototype._wrapBlock = function(context, block1, block2){
    var flow = this.style.flow;
    var measure = block1.getBoxMeasure(flow); // block2 has same measure
    var extent = block1.getBoxExtent(flow) + (block2? block2.getBoxExtent(flow) : 0);

    // wrapping block always float to start direction
    return this.style.createChild("div", {"float":"start"}).createBlock({
      elements:[block1, block2],
      measure:measure,
      extent:extent
    });
  };

  FloatLayoutGenerator.prototype._wrapFloat = function(context, floated, rest){
    var flow = this.style.flow;
    var measure = floated.getMeasure(flow) + (rest? rest.getBoxMeasure(flow) : 0);
    var extent = floated.getExtent(flow);
    return this.style.createChild("div").createBlock({
      elements:this._sortFloatRest(floated, rest),
      measure:measure,
      extent:extent
    });
  };
  
  FloatLayoutGenerator.prototype._yieldFloatSpace = function(context, measure, extent){
    var style = this._childLayout.style;
    style.resize(measure, extent);
    return this.yieldChildLayout(context.createStaticBlockContext(
      style.getContentMeasure(),
      style.getContentExtent()
    ));
  };
  
  FloatLayoutGenerator.prototype._yieldFloatStack = function(context){
    var start_blocks = [], end_blocks = [];
    var rest_extent = context.getBlockRestExtent();
    List.iter(this.generators, function(gen){
      gen.style.resizeExtent(rest_extent);
      var block = gen.yield();
      if(block){
	if(gen.style.isFloatStart()){
	  start_blocks.push(block);
	} else if(gen.style.isFloatEnd()){
	  end_blocks.push(block);
	}
      }
    });
    return new FloatGroupStack(this.style.flow, start_blocks, end_blocks);
  };

  FloatLayoutGenerator.prototype._getFloatedTags = function(){
    var parent_style = this.style;
    return this.stream.getWhile(function(token){
      return (token instanceof Tag && (new StyleContext(token, parent_style)).isFloated());
    });
  };

  FloatLayoutGenerator.prototype._getFloatedGenerators = function(){
    var parent_style = this.style;
    return List.map(this._getFloatedTags(), function(tag){
      return new BlockLayoutGenerator(
	new StyleContext(tag, parent_style),
	new TokenStream(tag.getContent())
      );
    });
  };

  return FloatLayoutGenerator;
})();

